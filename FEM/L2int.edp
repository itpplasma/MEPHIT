include "getARGV.idp"
int ktlownfluxp1 = getARGV("-N", 0);
string meshfile = getARGV("-M", "../PRELOAD/inputformaxwell_ext.msh");
string Bndifffile = getARGV("-B", "../MHD/Bn_diff.dat");
string convfile = getARGV("-C", "../MHD/convergence.dat");
bool doplot = false;

mesh Th = readmesh(meshfile);
fespace Vh0(Th, P0);
fespace Hdiv(Th, RT0);

Hdiv <complex> [Br, Bz];
Vh0 <complex> Bphi;

real BfluxRe, BfluxIm;
complex redundancy;

// count triangles in internal region 0
int ntri = 0;
for (int k = 0; k < Th.nt; k++) {
  if (Th[k].label == 0)
    ntri++;
}
if (ktlownfluxp1 <= 0) {
  ktlownfluxp1 = ntri;
}

cout << "Number of triangles in internal region: " << ntri << endl;

ifstream ifile(Bndifffile);
for (int k = 0; k < ktlownfluxp1; k++) {
  for (int j = 0; j < 3; j++) {
    redundancy = Br[][Hdiv(k, (j+2) % 3)];
    ifile >> BfluxRe >> BfluxIm;
    // check orientation of edges and assign
    // normal flux coordinate accordingly
    if ((Th[k][(j+1) % 3] - Th[k][(j+0) % 3]) > 0) {
      Br[][Hdiv(k, (j+2) % 3)] = BfluxRe + 1.0i * BfluxIm;
    } else {
      Br[][Hdiv(k, (j+2) % 3)] = -BfluxRe - 1.0i * BfluxIm;
    }
    if (redundancy != 0.0 && redundancy != Br[][Hdiv(k, (j+2) % 3)]) {
      cerr << "Flux inconsistent in file " << Bndifffile
        << " at triangle " << k << " edge " << (j+2) % 3 << ": "
        << redundancy << " != " << Br[][Hdiv(k, (j+2) % 3)] << endl;
      exit(1);
    }
  }
  ifile >> BfluxRe >> BfluxIm;
  Bphi[][k] = (BfluxRe + 1.0i * BfluxIm) / Th[k].area;
}

{
  ofstream cfile(convfile, append);
  cfile.scientific.precision(16);
  cfile << sqrt(real(int2d(Th)(Br * conj(Br) * x + Bz * conj(Bz) * x +
    Bphi * conj(Bphi) / x))) << endl;
}
