//
// Magnetostatics with Fourier modes in toroidal angle
//
// C. Albert, July 2016
//
//

real c = 29979245800.0; // speed of light
real eps = 1e-10;

real nmode = 2.0; // mode number

include "magdif.idp"  // config (incl. filenames)

mesh Th = readmesh(meshfile);

fespace Vh0(Th, P0);
fespace Vh1(Th, P1);
fespace Vh2(Th, P2);
fespace Hrot(Th, RT0Ortho);
fespace Hdiv(Th, RT0);

Hrot [axRe, ayRe], [axIm, ayIm], [wx, wy];
Hdiv [JrRe, JzRe], [JrIm, JzIm], [BrRe, BzRe], [BrIm, BzIm];

Vh0 BphiRe, BphiIm, JphiRe, JphiIm;

real[int] JfluxRe(Hdiv.ndof);
real[int] JfluxIm(Hdiv.ndof);
JfluxRe = 0.0;
JfluxIm = 0.0;

// count triangles in internal region 0
int nti = 0;
for (int k = 0; k < Th.nt; k++) {
  if (Th[k].label == 0)
    nti++;
}

cout << "Number of triangles in internal region: " << nti << endl;

ifstream ifile(currnfile);
for (int k = 0; k < nti; k++) {
  for (int j = 0; j < 3; j++) {
    real jotherRe = JfluxRe[Hdiv(k, (j+2) % 3)];
    real jotherIm = JfluxIm[Hdiv(k, (j+2) % 3)];    
    ifile >> JfluxRe[Hdiv(k, j)] >> JfluxIm[Hdiv(k, j)];
    // check orientation of edges and assign
    // normal flux coordinate accordingly
    if ((Th[k][(j+0) % 3] - Th[k][(j+2) % 3]) > 0) {
      JfluxRe[Hdiv(k, (j+1) % 3)] = -JfluxRe[Hdiv(k, (j+1) % 3)];
      JfluxIm[Hdiv(k, (j+1) % 3)] = -JfluxRe[Hdiv(k, (j+1) % 3)];
    }
    if (abs(jotherRe)>eps && abs(jotherRe-JfluxRe[Hdiv(k, (j+2) % 3)]) > eps*abs(jotherRe))
      cout << "Error: Real flux inconsistent at cell" << k << " " << j << endl;
    if (abs(jotherIm)>eps && abs(jotherIm-JfluxIm[Hdiv(k, (j+2) % 3)]) > eps*abs(jotherIm))
      cout << "Error: Imag flux inconsistent at cell" << k << " " << j << endl;
  }
  ifile >> JphiRe[][k] >> JphiIm[][k];
}
// Check:
// JphiRe = -(dx(JrIm) + dy(JzIm)) / nmode;
// JphiIm = (dx(JrRe) + dy(JzRe)) / nmode;

JrRe[] = JfluxRe;
JrIm[] = JfluxIm;

solve AmpereRe([axRe, ayRe], [wx, wy], solver = UMFPACK) = // defines the PDE
  int2d(Th)(x * (dx(wy) - dy(wx)) * (dx(axRe) - dy(axRe)))
  + int2d(Th)(nmode^2 / x * [wx, wy] '* [axRe, ayRe])
  - int2d(Th)([wx, wy] '* [y,-x])
//  - int2d(Th)(4.0 * pi / c * [wx, wy] '* [JrRe,JzRe])
  + on(1, axRe = 0, ayRe = 0);

solve AmpereIm([axIm, ayIm], [wx, wy], solver = UMFPACK) = // defines the PDE
  int2d(Th)(x * (dx(wy) - dy(wx)) * (dx(ayIm) - dy(axIm)))
  + int2d(Th)(nmode^2 / x * [wx, wy] '* [axIm, ayIm])
  - int2d(Th)([wx, wy] '* [y,-x])
//  - int2d(Th)(4.0 * pi / c * [wx, wy] '* [JrIm,JzIm])
  + on(1, axIm = 0, ayIm = 0);

[BrRe, BzRe] = [-nmode * ayIm, nmode * axIm];
[BrIm, BzIm] = [nmode * ayRe, -nmode * axRe];
BphiRe = -(dx(ayRe) - dy(axRe));
BphiIm = -(dx(ayIm) - dy(axIm));

ofstream ofile(Bnfluxfile);
ofile.scientific.precision(16);
for (int k = 0; k < Th.nt; k++) {
  for (int j = 0; j < 3; j++) {
    if ((Th[k][(j+0) % 3] - Th[k][(j+2) % 3]) > 0) {
      ofile
        << BrRe[][Hdiv(k, (j+1) % 3)] << "\t"
        << BrIm[][Hdiv(k, (j+1) % 3)] << "\t";
    } else {
      ofile
        << -BrRe[][Hdiv(k, (j+1) % 3)] << "\t"
        << -BrIm[][Hdiv(k, (j+1) % 3)] << "\t";
    }
  }
  ofile
    << BphiRe[][k] * Th[k].area << "\t"
    << BphiIm[][k] * Th[k].area << endl;
}

if (doplot) {
  plot(Th, wait = true);
  plot([JrRe, JzRe], wait = true, value = true);
  plot(JphiRe, wait = true, fill = true, value = true);
  plot([BrRe, BzRe], wait = true, value = true);
  plot(BphiRe, wait = true, fill = true, value = true);
}

