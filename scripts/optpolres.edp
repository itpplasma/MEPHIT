// set up environment
load "Element_Mixte"
load "gsl"
include "getARGV.idp"
int nflux = getARGV("-f", 110);
real R0 = getARGV("-R", 170000.0);
real Z0 = getARGV("-Z", 0.0);
int nmode = getARGV("-n", 2000);
int mmode = getARGV("-m", 9);
complex vaccoeff = getARGV("-C", 2.8114278075878412E+08);

// read radial positions and optimal poloidal resolution
real[int] rad(nflux);
int[int] npol(nflux);
real dummy;
ifstream fin("optpolres.dat");
for (int kf = 0; kf < nflux; kf++) {
  fin >> rad[kf] >> dummy;
  npol[kf] = 2 * lrint(0.5 * dummy);
}

// triangulate
int npoint = npol.sum + 1;
real[int] Rarr(npoint), Zarr(npoint);
Rarr[0] = R0; Zarr[0] = Z0;
int kpoint = 1;
for (int kf = 0; kf < nflux; kf++) {
  for (int kp = 0; kp < npol[kf]; kp++) {
    real theta = real(kp) / real(npol[kf]) * 2.0 * pi;
    Rarr[kpoint] = R0 + rad[kf] * cos(theta);
    Zarr[kpoint] = Z0 + rad[kf] * sin(theta);
    kpoint++;
  }
}
mesh Th = triangulate(Rarr, Zarr);
savemesh(Th, "optpolres.msh");

// project define vacuum
func complex KiLCABrad(int m, real rad, real theta) {
  real kzr = nmode / R0 * rad;
  return -0.5i * vaccoeff * (gslsfbesselIn(abs(m) - 1, kzr) + gslsfbesselIn(abs(m) + 1, kzr));
}
func complex KiLCABpol(int m, real rad, real theta) {
  real kzr = nmode / R0 * rad;
  return vaccoeff * m / kzr * gslsfbesselIn(abs(m), kzr);
}
func complex KiLCABtor(int m, real rad, real theta) {
  real kzr = nmode / R0 * rad;
  return vaccoeff * gslsfbesselIn(abs(m), kzr);
}
func complex KiLCABR(real R, real Z) {
  real rad, theta;
  rad = dist(R - R0, Z - Z0);
  theta = atan2(Z - Z0, R - R0);
  return (KiLCABrad(-mmode, rad, theta) * exp(-1i * mmode * theta) +
          KiLCABrad(mmode, rad, theta) * exp(1i * mmode * theta)) * cos(theta) -
    (KiLCABpol(-mmode, rad, theta) * exp(-1i * mmode * theta) +
     KiLCABpol(mmode, rad, theta) * exp(1i * mmode * theta)) * sin(theta);
}
func complex KiLCABZ(real R, real Z) {
  real rad, theta;
  rad = dist(R - R0, Z - Z0);
  theta = atan2(Z - Z0, R - R0);
  return (KiLCABrad(-mmode, rad, theta) * exp(-1i * mmode * theta) +
          KiLCABrad(mmode, rad, theta) * exp(1i * mmode * theta)) * sin(theta) +
    (KiLCABpol(-mmode, rad, theta) * exp(-1i * mmode * theta) +
     KiLCABpol(mmode, rad, theta) * exp(1i * mmode * theta)) * cos(theta);
}
func complex KiLCABphi(real R, real Z) {
  real rad, theta;
  rad = dist(R - R0, Z - Z0);
  theta = atan2(Z - Z0, R - R0);
  return (KiLCABtor(-mmode, rad, theta) * exp(-1i * mmode * theta) +
          KiLCABtor(mmode, rad, theta) * exp(1i * mmode * theta));
}
fespace Hdiv(Th, BDM1);
Hdiv <complex> [Br, Bz];
[Br, Bz] = [x * KiLCABR(x, y), x * KiLCABZ(x, y)];

// take samples for Fourier transform
real[int] halfrad(nflux);
int[int] ktmax(nflux);
halfrad[0] = 0.5 * rad[0];
ktmax[0] = npol[0];
for (int kf = 1; kf < nflux; kf++) {
  halfrad[kf] = 0.5 * (rad[kf-1] + rad[kf]);
  ktmax[kf] = npol[kf-1] + npol[kf];
}
{
  ofstream thetasweep("cmp_polres.dat");
  thetasweep.scientific.precision(15);
  int kf = nflux / 3 - 1;
  for (int kt = 0; kt < ktmax[kf]; kt++) {
    real theta = (kt + 0.5) / real(ktmax[kf]) * 2.0 * pi;
    x = R0 + halfrad[kf] * cos(theta);
    y = Z0 + halfrad[kf] * sin(theta);
    complex Bphi = (dx(Br) + dy(Bz)) * 1.0i / nmode;
    thetasweep << " " << halfrad[kf] << " " << theta
               << " " << real(KiLCABR(x, y)) << " " << imag(KiLCABR(x, y))
               << " " << real(KiLCABphi(x, y)) << " " << imag(KiLCABphi(x, y))
               << " " << real(KiLCABZ(x, y)) << " " << imag(KiLCABZ(x, y))
               << " " << real(Br) / x << " " << imag(Br) / x
               << " " << real(Bphi) << " " << imag(Bphi)
               << " " << real(Bz) / x << " " << imag(Bz) / x
               << endl;
  }
}
{
  ofstream rsweepr("ff_Bmn_vac_r.dat");
  ofstream rsweepth("ff_Bmn_vac_theta.dat");
  ofstream rsweepz("ff_Bmn_vac_z.dat");
  rsweepr.scientific.precision(15);
  rsweepth.scientific.precision(15);
  rsweepz.scientific.precision(15);
  int mmax = 24;
  complex[int] coeffrad(2*mmax+1), coeffpol(2*mmax+1), coefftor(2*mmax+1);
  complex Brad, Bpol, Btor;
  for (int kf = 0; kf < nflux; kf++) {
    coeffrad = 0.0;
    coeffpol = 0.0;
    coefftor = 0.0;
    for (int kt = 0; kt < ktmax[kf]; kt++) {
      real theta = (kt + 0.5) / real(ktmax[kf]) * 2.0 * pi;
      x = R0 + halfrad[kf] * cos(theta);
      y = Z0 + halfrad[kf] * sin(theta);
      Brad = Bz / x * sin(theta) + Br / x * cos(theta);
      Bpol = Bz / x * cos(theta) - Br / x * sin(theta);
      Btor = (dx(Br) + dy(Bz)) * 1.0i / nmode;
      for (int m = -mmax; m <= mmax; m++) {
        coeffrad[m + mmax] += Brad * exp(-1i * m * theta);
        coeffpol[m + mmax] += Bpol * exp(-1i * m * theta);
        coefftor[m + mmax] += Btor * exp(-1i * m * theta);
      }
    }
    coeffrad /= ktmax[kf];
    coeffpol /= ktmax[kf];
    coefftor /= ktmax[kf];
    rsweepr << " " << halfrad[kf] << " " << 0.0;
    rsweepth << " " << halfrad[kf] << " " << 0.0;
    rsweepz << " " << halfrad[kf] << " " << 0.0;
    for (int m = -mmax; m <= mmax; m++) {
      rsweepr << " " << real(coeffrad[m + mmax]);
      rsweepth << " " << real(coeffpol[m + mmax]);
      rsweepz << " " << real(coefftor[m + mmax]);
    }
    for (int m = -mmax; m <= mmax; m++) {
      rsweepr << " " << imag(coeffrad[m + mmax]);
      rsweepth << " " << imag(coeffpol[m + mmax]);
      rsweepz << " " << imag(coefftor[m + mmax]);
    }
    rsweepr << endl;
    rsweepth << endl;
    rsweepz << endl;
  }
}
