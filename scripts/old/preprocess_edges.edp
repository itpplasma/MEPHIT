//
// Magnetostatics with Fourier modes in toroidal angle
//
// C. Albert, July 2016
//
//
load "Element_Mixte";

real nmode = 2.0;  // mode number

bool doplot = true;
mesh Th = readmesh("maxwell.msh");

fespace Vh0(Th,P0);
fespace Vh1(Th,P1);
fespace Vh2(Th,P2);
fespace Hrot(Th,RT0Ortho);
fespace Hdiv(Th,RT0);
fespace Hdiv2(Th,RT1);

Vh1 bmod, psipol;
Hrot [dpsir,dpsiz];
Vh0 <complex> Br, Bz, hr, hz, hpsi;
Vh2 <complex> Br2, Bz2;
Vh0 hpsir, hpsii;

Hdiv <complex> [rBr,rBz];
Hdiv2 <complex> [rBr2,rBz2];
Vh0 <complex> rBp;

Br[] = 0; Bz[] = 0;

// count triangles in internal region 0
int nti = 0;
for (int kt=0; kt<Th.nt; kt++) {
  if(Th[kt].label==0)
    nti++;
}

bmod = 1e-30;

ifstream ifile("bmod_psipol_vac.dat");
for (int kt=0; kt<nti; kt++) {
  real b1, b2, b3, psi1, psi2, psi3;
  ifile >> b1 >> b2 >> b3 >> psi1 >> psi2 >> psi3;
  bmod[][Th[kt][0]] = b1;
  bmod[][Th[kt][1]] = b2;
  bmod[][Th[kt][2]] = b3;
  psipol[][Th[kt][0]] = psi1;
  psipol[][Th[kt][1]] = psi2;
  psipol[][Th[kt][2]] = psi3;
}

ifstream f1("BR_re.dat");
for (int kt=0; kt<nti; kt++) {
  real k,b;
  f1 >> k >> b;
  Br[][kt] = b;
}

ifstream f2("BR_im.dat");
for (int kt=0; kt<nti; kt++) {
  real k,b;
  f2 >> k >> b;
  Br[][kt] = Br[][kt] + 1.0i*b;
}

ifstream f3("BZ_re.dat");
for (int kt=0; kt<nti; kt++) {
  real k,b;
  f3 >> k >> b;
  Bz[][kt] = b;
}

ifstream f4("BZ_im.dat");
for (int kt=0; kt<nti; kt++) {
  real k,b;
  f4 >> k >> b;
  Bz[][kt] = Bz[][kt] + 1.0i*b;
}

hr = Br/bmod; hz = Bz/bmod;

Br2 = x*Br;
Bz2 = x*Bz;

[rBr2,rBz2] = [x*Br, x*Bz];

Vh1<complex> rBp2;
rBp2 = -1.0/(1.0i*nmode)*(dx(rBr2) + dy(rBz2));
rBp = rBp2;
//rBp = -1.0/(1.0i*nmode)*(dx(Br2) + dy(Bz2));

[dpsir,dpsiz] = [dx(psipol),dy(psipol)];

hpsi = (dx(psipol)*hr+dy(psipol)*hz);
hpsir = real(hpsi);
hpsii = imag(hpsi);

ofstream ofile2("hpsi_vac_fem.dat");
ofile2.precision(16);
for (int k=0; k<nti; k++) {
  ofile2.scientific 
	<< hpsir[][k] << "\t" << hpsii[][k] << endl;
}

Hrot [ux,uy],[vx,vy];   // for edge orientation
[ux,uy] = [1,0];
[vx,vy] = [0,1];

ofstream ofile3("hpsi_vac_flux.dat");
ofile3.precision(16);
for (int k=0; k<nti; k++) {
  real sig;
  if(abs(ux[][Hrot(k,2)]) > abs(vx[][Hrot(k,2)]))
    sig = (Th[k][1].x-Th[k][0].x)/ux[][Hrot(k,2)];
  else
    sig = (Th[k][1].y-Th[k][0].y)/vx[][Hrot(k,2)];
  ofile3.scientific << sig*real(rBr[][Hdiv(k,2)]) <<  "\t" << sig*imag(rBr[][Hdiv(k,2)]) << "\t";
  
  if(abs(ux[][Hrot(k,0)]) > abs(vx[][Hrot(k,0)]))
    sig = (Th[k][2].x-Th[k][1].x)/ux[][Hrot(k,0)];
  else
    sig = (Th[k][2].y-Th[k][1].y)/vx[][Hrot(k,0)];
  ofile3.scientific << sig*real(rBr[][Hdiv(k,0)]) <<  "\t" << sig*imag(rBr[][Hdiv(k,0)]) << "\t";
  
  if(abs(ux[][Hrot(k,1)]) > abs(vx[][Hrot(k,1)]))
    sig = (Th[k][0].x-Th[k][2].x)/ux[][Hrot(k,1)];
  else
    sig = (Th[k][0].y-Th[k][2].y)/vx[][Hrot(k,1)];
  ofile3.scientific << sig*real(rBr[][Hdiv(k,1)]) <<  "\t" << sig*imag(rBr[][Hdiv(k,1)]) << "\t";
  
  ofile3.scientific << real(rBp[][k]) << "\t" << imag(rBp[][k]) << endl;
}

if (doplot) {
  plot([rBr,rBz],fill=true,value=true,wait=true);
  plot(rBp,fill=true,value=true,wait=true);  
 }
