//
// Magnetostatics with Fourier modes in toroidal angle
//
// C. Albert, July 2016
//
//

include "getARGV.idp" 
mesh Th = readmesh(getARGV(1,"maxwell.msh"));

fespace Vh0(Th,P0);
fespace Vh1(Th,P1);
fespace Vh2(Th,P2);
fespace Hrot(Th,RT0Ortho);
fespace Hdiv(Th,RT0); 

Hrot [ux,uy],[vx,vy];   // for edge orientation
[ux,uy] = [1,0];
[vx,vy] = [0,1];

Hdiv<complex> [Jr,Jz];

Jr[] = 0.0 + 0.0i; Jz[] = 0.0 + 0.0i;

// count triangles in internal region 0
int nti = 0;
for (int k=0; k<Th.nt; k++) {
  if(Th[k].label==0)
    nti++;
}

ifstream ifile(getARGV(2,"currents.dat"));
for (int k=0; k<nti; k++) {
  real Jnr1, Jnr2, Jnr3, Jni1, Jni2, Jni3, sig;
  ifile >> Jnr1 >> Jnr2 >> Jnr3 >> Jni1 >> Jni2 >> Jni3;
  
  // check orientation of edges and assign
  // normal flux coordinate accordingly
  if(abs(ux[][Hrot(k,2)]) > abs(vx[][Hrot(k,2)]))
    sig = (Th[k][1].x-Th[k][0].x)/ux[][Hrot(k,2)];
  else
    sig = (Th[k][1].y-Th[k][0].y)/vx[][Hrot(k,2)];
  Jr[][Hdiv(k,2)] = sig*(Jnr1 + 1.0i*Jni1);
  
  if(abs(ux[][Hrot(k,0)]) > abs(vx[][Hrot(k,0)]))
    sig = (Th[k][2].x-Th[k][1].x)/ux[][Hrot(k,0)];
  else
    sig = (Th[k][2].y-Th[k][1].y)/vx[][Hrot(k,0)];
  Jr[][Hdiv(k,0)] = sig*(Jnr2 + 1.0i*Jni2);
  
  if(abs(ux[][Hrot(k,1)]) > abs(vx[][Hrot(k,1)]))
    sig = (Th[k][0].x-Th[k][2].x)/ux[][Hrot(k,1)];
  else
    sig = (Th[k][0].y-Th[k][2].y)/vx[][Hrot(k,1)];
  Jr[][Hdiv(k,1)] = sig*(Jnr3 + 1.0i*Jni3);
}

Hdiv [ReJr,ReJz], [ImJr, ImJz];
Vh0 absJ;

[ReJr,ReJz] = [real(Jr),real(Jz)];
[ImJr,ImJz] = [imag(Jr),imag(Jz)];

absJ = abs(Jr^2) + abs(Jz^2);
plot([ReJr,ReJz],fill=true,wait=true);
plot([ImJr,ImJz],fill=true,wait=true);
plot(absJ,fill=true,wait=true);
