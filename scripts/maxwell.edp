//
// Magnetostatics with Fourier modes in toroidal angle
//
// C. Albert, July 2016
//
//

load "MUMPS"

real c = 29979245800.0; // speed of light

include "getARGV.idp"
int nmode = getARGV("-n", 2);
int ktlownfluxp1 = getARGV("-N", 0);
string meshfile = getARGV("-M", "inputformaxwell_ext.msh");
string currnfile = getARGV("-J", "currn.dat");
string Bnfluxfile = getARGV("-B", "Bn.dat");
bool doplot = false;

mesh Th = readmesh(meshfile);

fespace Vh0(Th, P0);
fespace Vh1(Th, P1);
fespace Vh2(Th, P2);
fespace Hrot(Th, RT0Ortho);
fespace Hdiv(Th, RT0);

Hrot <complex> [ax, ay], [wx, wy];
Hdiv <complex> [Jr, Jz], [Br, Bz];
// use NaN to signify an unset value
[Jr, Jz] = [NaN() + 1.0i * NaN(), NaN() + 1.0i * NaN()];

Vh0 <complex> Bphi, Jphi;
Jphi = 0.0;

real JfluxRe, JfluxIm;
complex redundancy;
int DoF;

// count triangles in internal region 0
int ntri = 0;
for (int k = 0; k < Th.nt; k++) {
  if (Th[k].label == 0)
    ntri++;
}
if (ktlownfluxp1 <= 0) {
  ktlownfluxp1 = ntri;
}

cout << "Number of triangles in internal region: " << ntri << endl;

int inconsistent;
real small = 2.2250738585072014e-308, epsilon = 2.2204460492503131e-16; // taken from Fortran
cerr.scientific.precision(15);
ifstream ifile(currnfile);
for (int k = 0; k < ktlownfluxp1; k++) {
  for (int j = 0; j < 3; j++) {
    DoF = Hdiv(k, (j+2) % 3);
    redundancy = Jr[][DoF];
    ifile >> JfluxRe >> JfluxIm;
    // check orientation of edges and assign
    // normal flux coordinate accordingly
    if ((Th[k][(j+1) % 3] - Th[k][(j+0) % 3]) > 0) {
      Jr[][DoF] = JfluxRe + 1.0i * JfluxIm;
    } else {
      Jr[][DoF] = -JfluxRe - 1.0i * JfluxIm;
    }
    inconsistent = 0;
    // ordered comparisons with NaN always return false, so unset values are never inconsistent
    if (abs(real(redundancy)) < small) {
      inconsistent += abs(real(Jr[][DoF])) >= small;
    } else {
      inconsistent += abs(1.0 - real(Jr[][DoF]) / real(redundancy)) > epsilon;
    }
    if (abs(imag(redundancy)) < small) {
      inconsistent += abs(imag(Jr[][DoF])) >= small;
    } else {
      inconsistent += abs(1.0 - imag(Jr[][DoF]) / imag(redundancy)) > epsilon;
    }
    if (inconsistent) {
      cerr << "Flux inconsistent in file " << currnfile
           << " at triangle " << k << ", edge " << (j+2) % 3 << ": "
           << redundancy << " != " << Jr[][DoF] << endl;
      exit(1);
    }
  }
  ifile >> JfluxRe >> JfluxIm;
  Jphi[][k] = (JfluxRe + 1.0i * JfluxIm) / Th[k].area;
}
// set NaN values on the extended mesh to zero
for (int k = ktlownfluxp1; k < Th.nt; k++) {
  for (int j = 0; j < 3; j++) {
    DoF = Hdiv(k, j);
    if (isNaN(real(Jr[][DoF])) || isNaN(imag(Jr[][DoF]))) {
      Jr[][DoF] = 0.0 + 0.0i;
    }
  }
}

// Jphi = (dx(Jr) + dy(Jz)) * 1.0i / nmode;

// note that the metric determinant x = R is already contained in the input data
// for J and thus also in a and B
solve Ampere([ax, ay], [wx, wy], solver = sparsesolver) = // defines the PDE
  int2d(Th)(x * (dx(wy) - dy(wx)) * (dx(ay) - dy(ax)))
  + int2d(Th)(nmode^2 / x * (wx * ax + wy * ay))
  - int2d(Th)(4.0 * pi / c * (wx * Jr + wy * Jz))
  + on(1, ax = 0, ay = 0);

[Br, Bz] = [1.0i * nmode * ay, -1.0i * nmode * ax];
Bphi = -(dx(ay) - dy(ax));

ofstream ofile(Bnfluxfile);
ofile.scientific.precision(15);
for (int k = 0; k < ntri; k++) {
  for (int j = 0; j < 3; j++) {
    if ((Th[k][(j+1) % 3] - Th[k][(j+0) % 3]) > 0) {
      ofile
        << real(Br[][Hdiv(k, (j+2) % 3)]) << "\t"
        << imag(Br[][Hdiv(k, (j+2) % 3)]) << "\t";
    } else {
      ofile
        << -real(Br[][Hdiv(k, (j+2) % 3)]) << "\t"
        << -imag(Br[][Hdiv(k, (j+2) % 3)]) << "\t";
    }
  }
  ofile
    << real(Bphi[][k]) * Th[k].area << "\t"
    << imag(Bphi[][k]) * Th[k].area << endl;
}

if (doplot) {
  Hdiv [JrRe, JzRe], [JrIm, JzIm], [BrRe, BzRe], [BrIm, BzIm];
  [JrRe, JzRe] = [real(Jr), real(Jz)];
  [JrIm, JzIm] = [imag(Jr), imag(Jz)];
  [BrRe, BzRe] = [real(Br), real(Bz)];
  [BrIm, BzIm] = [imag(Br), imag(Bz)];
  plot(Th, wait = true);
  plot(JrRe, wait = true, value = true);
  plot(BrRe, wait = true, value = true);
  plot(Bphi, wait = true, fill = true, value = true);
}
