//
// Magnetostatics with Fourier modes in toroidal angle
//
// C. Albert, July 2016 (initial commit)
// P. Lainer, September 2020 (last change)
//

load "BinaryIO"
load "MUMPS"

real c = 29979245800.0; // speed of light

include "getARGV.idp"
string meshfile = getARGV("-M", "inputformaxwell_ext.msh");
string datapipe = getARGV("-P", "maxwell.dat");
bool doplot = false;

mesh Th = readmesh(meshfile);
// count triangles in internal region 0
int ntri = 0;
for (int k = 0; k < Th.nt; k++) {
  if (Th[k].label == 0)
    ntri++;
}
cout << "Number of triangles in internal region: " << ntri << endl;
fespace Vh0(Th, P0);
fespace Vh1(Th, P1);
fespace Vh2(Th, P2);
fespace Hrot(Th, RT0Ortho);
fespace Hdiv(Th, RT0);
Hrot <complex> [ax, ay], [wx, wy];
Hdiv <complex> [Jr, Jz], [Br, Bz];
Vh0 <complex> Bphi, Jphi;

real[int] fluxdata(8 * ntri); // (Re, Im) of RT0 DoFs + toroidal component
complex redundancy;
int DoF, inconsistent;
real small = 2.2250738585072014e-308, epsilon = 2.2204460492503131e-16; // taken from Fortran
cerr.scientific.precision(15);
// check orientation of edges and assign normal flux coordinate accordingly
// use NaN to signify an unset value
// ordered comparisons with NaN always return false, so unset values are never inconsistent
// when core region is processed, set NaN values on the extended mesh to zero
macro deserializeDoFs(pol, tor)
for (int k = 0; k < ntri; k++) {
  for (int j = 0; j < 3; j++) {
    DoF = Hdiv(k, (j+2) % 3);
    redundancy = pol[][DoF];
    if ((Th[k][(j+1) % 3] - Th[k][(j+0) % 3]) > 0) {
      pol[][DoF] = fluxdata[8*k + 2*j] + 1.0i * fluxdata[8*k + 2*j + 1];
    } else {
      pol[][DoF] = -fluxdata[8*k + 2*j] - 1.0i * fluxdata[8*k + 2*j + 1];
    }
    inconsistent = 0;
    if (abs(real(redundancy)) < small) {
      inconsistent += abs(real(pol[][DoF])) >= small;
    } else {
      inconsistent += abs(1.0 - real(pol[][DoF]) / real(redundancy)) > epsilon;
    }
    if (abs(imag(redundancy)) < small) {
      inconsistent += abs(imag(pol[][DoF])) >= small;
    } else {
      inconsistent += abs(1.0 - imag(pol[][DoF]) / imag(redundancy)) > epsilon;
    }
    if (inconsistent) {
      cerr << "Flux inconsistent for input flag " << state
           << " at triangle " << k << ", edge " << (j+2) % 3 << ": "
           << redundancy << " != " << pol[][DoF] << endl;
      exit(1);
    }
  }
  tor[][k] = (fluxdata[8*k + 6] + 1.0i * fluxdata[8*k + 7]) / Th[k].area;
}
for (int k = ntri; k < Th.nt; k++) {
  for (int j = 0; j < 3; j++) {
    DoF = Hdiv(k, j);
    if (isNaN(real(pol[][DoF])) || isNaN(imag(pol[][DoF]))) {
      pol[][DoF] = 0.0 + 0.0i;
    }
  }
}
// end macro deserializeDoFs
macro serializeDoFs(pol, tor)
for (int k = 0; k < ntri; k++) {
  for (int j = 0; j < 3; j++) {
    if ((Th[k][(j+1) % 3] - Th[k][(j+0) % 3]) > 0) {
      fluxdata[8*k + 2*j] = real(pol[][Hdiv(k, (j+2) % 3)]);
      fluxdata[8*k + 2*j + 1] = imag(pol[][Hdiv(k, (j+2) % 3)]);
    } else {
      fluxdata[8*k + 2*j] = -real(pol[][Hdiv(k, (j+2) % 3)]);
      fluxdata[8*k + 2*j + 1] = -imag(pol[][Hdiv(k, (j+2) % 3)]);
    }
  }
  fluxdata[8*k + 6] = real(tor[][k]) * Th[k].area;
  fluxdata[8*k + 7] = imag(tor[][k]) * Th[k].area;
}
// end macro serializeDoFs

real[int] integral(1);  // for SaveVec
int nmode = 2;
LoadFlag(nmode, datapipe);
flag(nmode, datapipe);
problem Ampere([ax, ay], [wx, wy], solver = sparsesolver) = // defines the PDE
  int2d(Th)(x * (dx(wy) - dy(wx)) * (dx(ay) - dy(ax)))
  + int2d(Th)(nmode^2 / x * (wx * ax + wy * ay))
  - int2d(Th)(4.0 * pi / c * (wx * Jr + wy * Jz))
  + on(1, ax = 0, ay = 0);
int state = 0;
while (state != -3) {
  LoadFlag(state, datapipe);
  flag(state, datapipe);
  if (state == -1) {
    // Ampere solver
    LoadVec(fluxdata, datapipe);
    [Jr, Jz] = [NaN() + 1.0i * NaN(), NaN() + 1.0i * NaN()];
    deserializeDoFs(Jr, Jphi);
    // note that the metric determinant x = R is already contained in the input data
    // for J, but not in A
    Ampere;
    // contravariant density components include factor R
    [Br, Bz] = [1.0i * nmode * ay, -1.0i * nmode * ax];
    // contravariant density component identical to physical component
    Bphi = -(dx(ay) - dy(ax));
    serializeDoFs(Br, Bphi);
    SaveVec(fluxdata, datapipe);
    if (doplot) {
      Hdiv [JrRe, JzRe], [JrIm, JzIm], [BrRe, BzRe], [BrIm, BzIm];
      [JrRe, JzRe] = [real(Jr), real(Jz)];
      [JrIm, JzIm] = [imag(Jr), imag(Jz)];
      [BrRe, BzRe] = [real(Br), real(Bz)];
      [BrIm, BzIm] = [imag(Br), imag(Bz)];
      plot(Th, wait = true);
      plot(JrRe, wait = true, value = true);
      plot(BrRe, wait = true, value = true);
      plot(Bphi, wait = true, fill = true, value = true);
    }
  } else if (state == -2) {
    // convergenve estimation
    LoadVec(fluxdata, datapipe);
    [Br, Bz] = [NaN() + 1.0i * NaN(), NaN() + 1.0i * NaN()];
    deserializeDoFs(Br, Bphi);
    integral[0] = sqrt(real(int2d(Th)(Br * conj(Br) + Bz * conj(Bz))));
    SaveVec(integral, datapipe);
  }
}
