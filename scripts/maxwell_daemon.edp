//
// Magnetostatics with Fourier modes in toroidal angle
//
// C. Albert, July 2016 (initial commit)
// P. Lainer, September 2020 (last change)
//

load "BinaryIO"
load "MUMPS"

real c = 29979245800.0; // speed of light

include "getARGV.idp"
string edgefile = "edgemap.dat";
string datapipe = getARGV("-P", "maxwell.dat");
bool doplot = false;

int runmode = 0, nmode = 2, nedge = 0, state = 0;
LoadFlag(nmode, datapipe);
flag(nmode, datapipe);
LoadFlag(nedge, datapipe);
flag(nedge, datapipe);
LoadFlag(runmode, datapipe);
flag(runmode, datapipe);
if (runmode % 2) {
  LoadFlag(state, datapipe);
  flag(state, datapipe);
  include "extmesh.edp"
}
if (!((runmode / 2) % 2)) {
  exit(0);
}
mesh Th = readmesh("maxwell.msh");
// count triangles in internal region 0
int ntri = 0;
for (int k = 0; k < Th.nt; k++) {
  if (Th[k].label == 0)
    ntri++;
}
cout << "Number of triangles in internal region: " << ntri << endl;
fespace Vh0(Th, P0);
fespace Vh1(Th, P1);
fespace Vh2(Th, P2);
fespace Hrot(Th, RT0Ortho);
fespace Hdiv(Th, RT0);
Hrot <complex> [ax, ay], [wx, wy];
Hdiv <complex> [Jr, Jz], [Br, Bz];
Vh0 <complex> Bphi, Jphi;

int[int] edgemap(nedge), signmap(nedge);
{
  ifstream in(edgefile);
  int ke, ktri;
  for (int kedge = 0; kedge < nedge; kedge++) {
    in >> ktri >> ke;
    // ke and ktri are one-based indices and edge numbering is shifted by one
    edgemap[kedge] = Hdiv(ktri - 1, (abs(ke) + 1) % 3);
    // the sign of ke indicates when edge orientation differs in FreeFem
    signmap[kedge] = (ke > 0) ? 1 : -1;
  }
}
real[int] fluxdata(2 * nedge); // (Re, Im) of RT0 DoFs
macro deserializeDoFs(pol)
for (int k = 0; k < nedge; k++) {
  pol[][edgemap[k]] = signmap[k] * (fluxdata[2 * k] + 1.0i * fluxdata[2 * k + 1]);
}
// end macro deserializeDoFs
macro serializeDoFs(pol)
for (int k = 0; k < nedge; k++) {
  fluxdata[2 * k] = signmap[k] * real(pol[][edgemap[k]]);
  fluxdata[2 * k + 1] = signmap[k] * imag(pol[][edgemap[k]]);
}
// end macro serializeDoFs

real[int] integral(1);  // for SaveVec
problem Ampere([ax, ay], [wx, wy], solver = sparsesolver) = // defines the PDE
  int2d(Th)(x * (dx(wy) - dy(wx)) * (dx(ay) - dy(ax)))
  + int2d(Th)(nmode^2 / x * (wx * ax + wy * ay))
  - int2d(Th)(4.0 * pi / c * (wx * Jr + wy * Jz))
  + on(2, ax = 0, ay = 0);
state = 0;
while (state != -3) {
  LoadFlag(state, datapipe);
  flag(state, datapipe);
  if (state == -1) {
    // Ampere solver
    LoadVec(fluxdata, datapipe);
    [Jr, Jz] = [0.0 + 0.0i, 0.0 + 0.0i];
    deserializeDoFs(Jr);
    // note that the metric determinant x = R is already contained in the input data
    // for J, but not in A
    Ampere;
    // contravariant density components include factor R
    [Br, Bz] = [1.0i * nmode * ay, -1.0i * nmode * ax];
    // contravariant density component identical to physical component
    Bphi = -(dx(ay) - dy(ax));
    serializeDoFs(Br);
    SaveVec(fluxdata, datapipe);
    if (doplot) {
      Hdiv [JrRe, JzRe], [JrIm, JzIm], [BrRe, BzRe], [BrIm, BzIm];
      [JrRe, JzRe] = [real(Jr), real(Jz)];
      [JrIm, JzIm] = [imag(Jr), imag(Jz)];
      [BrRe, BzRe] = [real(Br), real(Bz)];
      [BrIm, BzIm] = [imag(Br), imag(Bz)];
      plot(Th, wait = true);
      plot(JrRe, wait = true, value = true);
      plot(BrRe, wait = true, value = true);
      plot(Bphi, wait = true, fill = true, value = true);
    }
  } else if (state == -2) {
    // convergenve estimation
    LoadVec(fluxdata, datapipe);
    [Br, Bz] = [0.0 + 0.0i, 0.0 + 0.0i];
    deserializeDoFs(Br);
    integral[0] = sqrt(int2d(Th, 0, qforder=4)(real(Br * conj(Br) + Bz * conj(Bz))));
    SaveVec(integral, datapipe);
  }
}
